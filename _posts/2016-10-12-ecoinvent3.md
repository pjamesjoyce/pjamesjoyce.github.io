---
layout: post
title:  "Manipulating markets in ecoinvent 3"
date:   2016-10-12 14:10:02 +0200
categories: research ocelot
---


# Manipulating markets in ecoinvent 3

## The challenge

LCA can be a powerful tool for demonstrating the environmental credentials of products and technologies that are in development. When future products or technologies are assessed using LCA, while the foreground system can be manipulated to reflect the world they are likely to be released into, the background system is static, reflecting current technology mixes. This might lead to inconsistencies when assessing future scenarios using LCA.

For example, decarbonisation of the electricity grid is likely to improve the global warming impact associated with the life cycle of electric vehicles. In a standard LCA, the foreground system can be altered to utilise lower carbon electricity sources in the use phase. It may also be possible to alter the electricity mix used by the assembly process and the production of key components. However, as the supply chain gets more and complex and intertwined, manual edits to the electricity mix used become burdensome.

Similarly, aluminium is replacing steel in a number of new products with it's lightweight properties billed as reducing environmental impact (e.g. car engine blocks ([Bonollo et al. 2006](http://www.gruppofrattura.it/ors/index.php/MST/article/viewFile/1119/1071))). However, concurrently the production of aluminium is shifting towards China. From almost a standing start in the late 90's, China accounted for over half of primary aluminium production in 2015.

![Proportion of primary aluminium production](https://i.imgsafe.org/3d7bb5354c.png)

Aluminium smelting requires a large amount of electricity (around 14 kWh/kg), which in China is mainly produced at coal fired power stations. As a result, the net benefits from lightweighting may diminish as the impact of aluminium production with coal power increases.

By making targeted alterations to the system model that builds the background database, markets for exchanges such as electricity, aluminium, or any other exchange, can be updated database-wide to reflect the future scenario we are seeking to assess with our LCA. If the process is simple enough, powerful sensitivity analyses may be possible where products or technologies can be tested out according to a variety of possible future scenarios.

## The idea

The aim of this element of the project was to create a simple way to use external data (in the form of a machine readable .csv file) to manipulate the composition of markets within the ecoinvent database.
In order to create markets, the Ocelot linking algorithm uses the relative share of production volumes in the regions contained within that market to allocate and despatch the demand. By editing the production volumes of targeted transformation processes during the construction of the system model, the resulting markets can be manipulated to represent any mix desired by the user

## Visual representation

![Market manipulation diagram](https://i.imgsafe.org/10f3528188.png)

<center>*For a given number of transforming activites within a region, the production volume of the reference product is changed using external data, and these altered production volumes (PV') are used to direct the linking for the appropriate regional market*</center>

## Preparing the external data

Each transforming process in the ecoinvent database is identified by a universally unique identifier.
These can be found in the [activity overview](http://www.ecoinvent.org/support/documents-and-files/information-on-ecoinvent-3/information-on-ecoinvent-3.html) spreadsheet available from the econinvent website.

The file used to manipulate the markets consists of two columns, one for uuid, and one for the new production volume.

For example:

|                uuid                |production volume|
|:----------------------------------:|----------------:|
|7f093291-b86f-40c8-933e-90b18711a515|123456           |
|be256386-9de6-43c3-8b1f-0dacdce19312|756543           |
|...                                 |...              |

The default setting for reading the file is separated by commas, with a header row, i.e.:

```
uuid,"production volume"
7f093291-b86f-40c8-933e-90b18711a515,123456
be256386-9de6-43c3-8b1f-0dacdce19312,756543
```
however, this can be altered by changing the ```sep``` and ```header``` keyword arguments in `read_edit_csv`

## The code

The code is stored as a module called `market_manipulator`

This includes some utility functions (`get_dataset_by_id` and `get_dataset_by_code`) used within the new transformation function, and also some output functions (`list_techno_inputs`) to see the effects of our changes.

The main module includes a function to read the .csv file into the format required by the new transformation function
(a dictionary with the id of the transformation process as the key and the new production volume as the value)

```python

def read_edit_csv(filename, sep = ",", header=True):
    """read a csv file (column 0 = ids, column 1 = new production volumes) into the format required by edit_pv_of_reference_products"""
    with open(filename) as csvfile:

        my_edits = {}

        for i, line in enumerate(csvfile):
            if header == False or i>0:
                ls = line.strip().split(sep)
                my_edits[ls[0]]=ls[1]

        return my_edits
        
```

Below is the full version of the new transformation function to be used in the compilation of the system model

It takes two positional arguments, the first is the dataset being transformed, the second is the dictionary of edits to make, in the format output by `read_edit_csv`

This function changes the production volumes of the reference product of the specified transforming activities and logs the changes made

```python
import logging

def edit_pv_of_reference_products(data, edits_to_make):
    """edit the production volumes of a set of activities
        this is specified in a dictionary with the keys as the ids and the values as the new production volume
        Note - this function is 'curried' with its dictionary to become edit_specified_pvs(data)"""
   
    for edit in edits_to_make:
        dataset = get_dataset_by_id(edit, data)
        ref_product = get_single_reference_product(dataset)
        original_pv = ref_product['production volume']['amount']
        new_pv = edits_to_make[edit]
        ref_product['production volume']['amount'] = float(new_pv)
        print ('Production volume for {} {} changed from {} to {}'.format(dataset['name'], dataset['location'],original_pv, new_pv))
        logging.info({
                'type': 'table element',
                'data': (dataset['name'], dataset['location'],original_pv, new_pv)
            })
    return data

edit_pv_of_reference_products.__table__ = {
    'title': 'Alter the production volume of specified transforming activities',
    'columns': ["Activity", "Location", "Original", "New"]
}
```

`read_edit_csv` and `edit_pv_of_reference_products` can be imported and utilised in the generation of alternative system models.

To make life slightly easier however, we can write an alternative version of Ocelot's built in `system_model` function to apply the edits in our csv file to the default Ocelot configuration.

This function takes two arguments, the path to the ecospold files and the path to the .csv file

It returns the results of `system_model` using the new configuration which it sets up.

First it imports the elements of Ocelot it requires (`system_model`, `default_configuration` and `link_markets`), and `partial` from `functools`.

Then it uses `read_edit_csv` to read in the specified file of edits.

In order for the transformation function to be applied by the Ocelot `system_model` function, the external data needs to be 'curried' into a function that takes the dataset as a single positional argument. This function is called `edit_specified_pvs`

Next, we need to create a new, custom configuration. We do this by finding the `link_markets` collection in the `default_configuration` and inserting our new `edit_specified_pvs` function beforehand.

Finally we run `system_model` on our data files using our new configuration and return the filepath and the data.

```python
def system_model_with_pv_edits (data_path, edit_csv_file):
    from ocelot import system_model, default_configuration
    from ocelot.transformations.locations import link_markets    
    from functools import partial
    
    my_edits = read_edit_csv(edit_csv_file)

    edit_specified_pvs = partial(edit_pv_of_reference_products, edits_to_make=my_edits)

    linking_function_index = default_configuration.index(link_markets)

    custom_configuration = list(default_configuration)
    custom_configuration.insert(linking_function_index, edit_specified_pvs)

    # run the system model
    fp, data = system_model(data_path, custom_configuration)
    
    return fp, data
```

## Case study - Aluminium production moving to China

Below is an example, in which we change the market for aluminium such that 80% of primary ingot is produced in China. Given the current rate of growth of China's market share, this may become a reality in the next decade.


```python
from market_manipulator import system_model_with_pv_edits

new_pv_file = "path/to/edits.csv"

data_path = "path/to/unlinked/ecospold/files"  

fp, data = system_model_with_pv_edits(data_path, new_pv_file)
```

    Starting Ocelot model run
    ...
    Saving final results
    

## So what have we done?

If we know the id of the market process we want to have altered, we can use the `list_techno_inputs` utility function from the `market_manipulator` module to check the inputs to the market. If the new system model has worked, 80% of the inputs of aluminium should be from China


```python
from market_manipulator.outputs import list_techno_inputs

RoW_Al_market = "92bb65cf-89fa-45f1-9b40-38d762e16805"
list_techno_inputs(RoW_Al_market,data)
```

    There are 9 inputs to the technosphere in market for aluminium, primary, ingot RoW

<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>location</th>
      <th>amount</th>
      <th>unit</th>
      <th>percentage</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>6</th>
      <td>aluminium production, primary, ingot</td>
      <td>CN</td>
      <td>0.8000</td>
      <td>kg</td>
      <td>80.00%</td>
    </tr>
    <tr>
      <th>2</th>
      <td>aluminium production, primary, ingot</td>
      <td>IAI Area, Russia &amp; RER w/o EU27 &amp; EFTA</td>
      <td>0.0391</td>
      <td>kg</td>
      <td>3.91%</td>
    </tr>
    <tr>
      <th>4</th>
      <td>aluminium production, primary, ingot</td>
      <td>IAI Area, Gulf Cooperation Council</td>
      <td>0.0341</td>
      <td>kg</td>
      <td>3.41%</td>
    </tr>
    <tr>
      <th>3</th>
      <td>aluminium production, primary, ingot</td>
      <td>IAI Area, Asia, without China and GCC</td>
      <td>0.0283</td>
      <td>kg</td>
      <td>2.83%</td>
    </tr>
    <tr>
      <th>8</th>
      <td>aluminium production, primary, ingot</td>
      <td>CA-QC</td>
      <td>0.0227</td>
      <td>kg</td>
      <td>2.27%</td>
    </tr>
    <tr>
      <th>0</th>
      <td>aluminium production, primary, ingot</td>
      <td>IAI Area, North America, without Quebec</td>
      <td>0.0210</td>
      <td>kg</td>
      <td>2.10%</td>
    </tr>
    <tr>
      <th>5</th>
      <td>aluminium production, primary, ingot</td>
      <td>UN-OCEANIA</td>
      <td>0.0204</td>
      <td>kg</td>
      <td>2.04%</td>
    </tr>
    <tr>
      <th>1</th>
      <td>aluminium production, primary, ingot</td>
      <td>IAI Area, South America</td>
      <td>0.0191</td>
      <td>kg</td>
      <td>1.91%</td>
    </tr>
    <tr>
      <th>7</th>
      <td>aluminium production, primary, ingot</td>
      <td>IAI Area, Africa</td>
      <td>0.0153</td>
      <td>kg</td>
      <td>1.53%</td>
    </tr>
  </tbody>
</table>
</div>



Success! Next we can load this new database into brightway2 to see what effect this has had on the impact assessment results

## Comparing the new system model to the default in brightway2


First we need to run the default configuration system model to compare to 


```python
from ocelot import system_model
def_fp, def_data = system_model(data_path);
```

    Starting Ocelot model run
    ...
    Saving final results
    

```python
list_techno_inputs(RoW_Al_market,def_data)
```

    There are 9 inputs to the technosphere in market for aluminium, primary, ingot RoW

<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>location</th>
      <th>amount</th>
      <th>unit</th>
      <th>percentage</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2</th>
      <td>aluminium production, primary, ingot</td>
      <td>IAI Area, Russia &amp; RER w/o EU27 &amp; EFTA</td>
      <td>0.0957</td>
      <td>kg</td>
      <td>9.57%</td>
    </tr>
    <tr>
      <th>4</th>
      <td>aluminium production, primary, ingot</td>
      <td>IAI Area, Gulf Cooperation Council</td>
      <td>0.0837</td>
      <td>kg</td>
      <td>8.37%</td>
    </tr>
    <tr>
      <th>3</th>
      <td>aluminium production, primary, ingot</td>
      <td>IAI Area, Asia, without China and GCC</td>
      <td>0.0693</td>
      <td>kg</td>
      <td>6.93%</td>
    </tr>
    <tr>
      <th>6</th>
      <td>aluminium production, primary, ingot</td>
      <td>CN</td>
      <td>0.5061</td>
      <td>kg</td>
      <td>50.61%</td>
    </tr>
    <tr>
      <th>8</th>
      <td>aluminium production, primary, ingot</td>
      <td>CA-QC</td>
      <td>0.0595</td>
      <td>kg</td>
      <td>5.95%</td>
    </tr>
    <tr>
      <th>0</th>
      <td>aluminium production, primary, ingot</td>
      <td>IAI Area, North America, without Quebec</td>
      <td>0.0515</td>
      <td>kg</td>
      <td>5.15%</td>
    </tr>
    <tr>
      <th>5</th>
      <td>aluminium production, primary, ingot</td>
      <td>UN-OCEANIA</td>
      <td>0.0499</td>
      <td>kg</td>
      <td>4.99%</td>
    </tr>
    <tr>
      <th>1</th>
      <td>aluminium production, primary, ingot</td>
      <td>IAI Area, South America</td>
      <td>0.0469</td>
      <td>kg</td>
      <td>4.69%</td>
    </tr>
    <tr>
      <th>7</th>
      <td>aluminium production, primary, ingot</td>
      <td>IAI Area, Africa</td>
      <td>0.0374</td>
      <td>kg</td>
      <td>3.74%</td>
    </tr>
  </tbody>
</table>
</div>


Import brightway 2, and the Ocelot to brightway IO module


```python
from brightway2 import *
```

Open or create and set up the Ecoinvent3_3 project


```python
my_project = "Ecoinvent3_3"

if my_project not in projects:
    print("Creating '{}' project".format(my_project))
    projects.set_current(my_project)
    bw2setup() # if its new, run `bw2setup()` to set up the biosphere flows and methods
else:
    print("Switching to '{}' project".format(my_project))
    projects.set_current(my_project)

```

    Switching to 'Ecoinvent3_3' project
    

Import the two newly created databases into brightway2


```python
new_database_name = "Ecoinvent3_3_cutoff_AlCN80"
new_db = import_into_brightway2(data, new_database_name)

default_database_name = "Ecoinvent3_3_cutoff"
def_db = try_database_import(def_data, default_database_name)
```

Next we can choose some methods to use in our assessment

```python
my_methods = {
    'GWP' : [('IPCC 2013', 'GWP', '100 years'), 'Global warming potential (kg CO2-eq)'],
    'ECO' : [('ReCiPe Endpoint (E,A)', 'ecosystem quality', 'total'),'Ecosystem quality (ReCiPe points)'],
    'HUM' : [('ReCiPe Endpoint (E,A)', 'human health', 'total'),'Human health (ReCiPe points)'],
    'RES' : [('ReCiPe Endpoint (E,A)', 'resources', 'total'),'Resource depletion  (ReCiPe points)']
    }
```

Then create LCA objects for the default and newly customised database, compute the LCI, with factorisation, and then run the LCIA.


```python
def switch_method(db, method):
    my_lca = LCA({db.random(): 1}, method=method)
    my_lca.lci(factorize=True)
    my_lca.lcia()
    
    return my_lca
```

```python
def_lca = switch_method(def_db, my_methods['GWP'][0])
```

```python
new_lca = switch_method(new_db, my_methods['GWP'][0])
```


### Aluminium production

_Note: you can find the `check_results` function at the bottom of this post_
```python
plot,table = check_results('market aluminium ingot RoW')
table
```


<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>database</th>
      <th>Ecoinvent3_3_cutoff</th>
      <th>Ecoinvent3_3_cutoff_AlCN80</th>
      <th>% difference</th>
    </tr>
    <tr>
      <th>item</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>market for aluminium, primary, ingot | RoW</th>
      <td>18.05</td>
      <td>20.64</td>
      <td>14.38</td>
    </tr>
  </tbody>
</table>
</div>




![png](/assets/images/output_49_1.png)


The GWP impact of the RoW market for primary aluminium ingot and GLO markets for wrought and cast alloy (which take primary ingot as an input) have been affected by the changes to the system model. They have increased by around 14%. This is likely to be due to the predominant use of electricity from coal in the Hall-Héroult process.

It's interesting to note that the market for aluminium in the EU (where no aluminium is imported from China) is relatively unaffected, with only a 0.03% increase in impact. This means that we haven't directly affected this market, but the changes we've made to RoW aluminium seem to have propagated through the database and led to a slight increase as a result of distant inputs to the process. This is exactly what we wanted.

### Products known to contain aluminium

We can extend our analysis explore the propagation of our changes through the background database.
Switching back to GWP impact, we can look at products which we know to contain aluminium, for example aluminium window frames.
Again we can see that we have brought about an increase, this time of (12.25%) as a result of increasing the impact of aluminium.


```python
plot, table = check_results('window frame production aluminium RoW')
table
```

### Looking more broadly

Taking a broader approach, we can look at things that are likely to have aluminium in their supply chain as a component of a constituent part, for example passenger cars.
Here we can see that the percentage differences as a result of our changes vary between 0.25% and 6.41%, most likely related to the amount of aluminium in the various components.


```python
plot, table = check_results('lorry production metric')
table
```

<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>database</th>
      <th>Ecoinvent3_3_cutoff</th>
      <th>Ecoinvent3_3_cutoff_AlCN80</th>
      <th>% difference</th>
    </tr>
    <tr>
      <th>item</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>lorry production, with refrigeration machine, carbon dioxide, liquid as refrigerant, 16 metric ton | GLO</th>
      <td>26623.69</td>
      <td>27435.39</td>
      <td>3.05</td>
    </tr>
    <tr>
      <th>lorry production, with refrigeration machine, R134a as refrigerant, 16 metric ton | GLO</th>
      <td>27285.76</td>
      <td>28097.49</td>
      <td>2.97</td>
    </tr>
    <tr>
      <th>lorry production, 40 metric ton | RER</th>
      <td>42533.60</td>
      <td>43633.08</td>
      <td>2.58</td>
    </tr>
    <tr>
      <th>lorry production, 40 metric ton | RoW</th>
      <td>42533.70</td>
      <td>43633.18</td>
      <td>2.58</td>
    </tr>
    <tr>
      <th>lorry production, 28 metric ton | RER</th>
      <td>29866.15</td>
      <td>30574.45</td>
      <td>2.37</td>
    </tr>
    <tr>
      <th>lorry production, 28 metric ton | RoW</th>
      <td>29866.25</td>
      <td>30574.55</td>
      <td>2.37</td>
    </tr>
    <tr>
      <th>lorry production, 16 metric ton | RER</th>
      <td>20207.10</td>
      <td>20645.01</td>
      <td>2.17</td>
    </tr>
    <tr>
      <th>lorry production, 16 metric ton | RoW</th>
      <td>20207.20</td>
      <td>20645.11</td>
      <td>2.17</td>
    </tr>
    <tr>
      <th>waste collection lorry production, 21 metric ton | CH</th>
      <td>39767.00</td>
      <td>40343.95</td>
      <td>1.45</td>
    </tr>
    <tr>
      <th>waste collection lorry production, 21 metric ton | RoW</th>
      <td>39767.00</td>
      <td>40343.95</td>
      <td>1.45</td>
    </tr>
  </tbody>
</table>
</div>




![png](/assets/images/output_58_1.png)


## Conclusions and next steps

We set out to create a simple way for LCA practitioners to manipulate the make up of markets within the ecoinvent database in such a way that these changes propagate through the database and influence the entire background system.
The newly created `market_manipulator` module does just this. 
With two commands...

```python
from market_manipulator import system_model_with_pv_edits

fp, data = system_model_with_pv_edits('path/to/unlinked/spold/files', 'path/to/csv/file')
```

...the production volumes, and hence the resulting market for a given exchange can be edited. The practitioners themselves just need to know how to create the csv and they can use it straight away without needing to know the detail behind it.

As the results show, throwing a stone of this kind into the ecoinvent 'pond' creates ripples throughout the database. Manipulating the market for aluminium for example, affects a wide number of processes to a greater or lesser extent.

Two lines of future development are immediately apparent. 

Firstly, for some markets the opportunity to add technologies that produce the reference product but which do not exist in that region may be useful. For example, introducing renewable technologies for electricity production into regions where it does not currently exist. Work by other groups to regionalise global datasets is likely to be very helpful in developing this strand.

Secondly, while the current format of the .csv file is efficiently machine readable, it is not particularly intuitive for human users. The development of a simple excel spreadsheet which can be filtered by reference product and region where the user can manipulate the production volumes and then output the necessary .csv file is likely to be a useful addition.






#_These functions make it easier to assess and visualise our results_


```python
def check_method():
    m = def_lca.method
    for i in my_methods.keys():
        if m in my_methods[i]:
            r = my_methods[i][1]
            break
    return r
```


```python
# Render our plots inline
%matplotlib inline

    
import pandas as pd
import matplotlib.pyplot as plt

plt.style.use('ggplot')
plt.rcParams['figure.figsize'] = (15, 5)



def check_results(search_term):
    """Search for something in the databases and create a table and chart of LCIA results for each item you find"""
    pd.options.display.float_format = '{:.2f}'.format
    
    results = []
    max_results = 12
    too_many = False
    
    def_search = sorted(def_db.search(search_term))
    new_search = sorted(new_db.search(search_term))
    
    if len(def_search) + len(new_search) == 0:
        return 'Nothing found, sorry...'
    
    for i, item in enumerate(def_search):
        if i > max_results:
            too_many=True
            break
        def_lca.redo_lcia({item: 1})
        results.append({'item':"{} | {}".format(item['name'],item['location']), 'amount':'1 {}'.format(item['unit']), 'score':def_lca.score, 'database':def_db.name})
        
    for i, item in enumerate(new_search):
        if i > max_results:
            too_many=True
            break
        new_lca.redo_lcia({item: 1})
        results.append({'item':"{} | {}".format(item['name'],item['location']), 'amount':'1 {}'.format(item['unit']), 'score':new_lca.score, 'database':new_db.name})
        
    if too_many:
        print ('More than max number of items ({}) found, only first {} shown'.format(max_results, max_results))
    df = pd.DataFrame(results)[['item', 'database', 'amount','score']]
    
    p = df.groupby(['item', 'database']).agg(sum)
   
    p = p.unstack()
    p.columns = p.columns.droplevel()
    
    p['% difference']= ((p[new_db.name]-p[def_db.name])/p[def_db.name])*100
    
    p.sort_values('% difference', ascending=False, inplace =True)
    
    plotdata = p.drop('% difference',axis=1)
    
    l_names =p.index.tolist()
    
    from textwrap import fill
    wrapAt = int(120/len(l_names))
    labels = [ fill(l, wrapAt, break_long_words=False) for l in l_names]
    
    plot = plotdata.plot(kind='bar', rot=0)
    plot.set_xticklabels(labels)
    plot.legend(loc='upper right', bbox_to_anchor=(1, 1.2))
    t = check_method()
    plot.set_title(label=t)
    
    return plot, p    
    
```
